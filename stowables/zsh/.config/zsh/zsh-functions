function zsh_add_file() {
    [ -f "$ZDOTDIR/$1" ] && source "$ZDOTDIR/$1"
}

function zsh_add_plugin() {
    PLUGIN_NAME=$(echo $1 | cut -d "/" -f 2)
    if [ -d "$ZDOTDIR/plugins/$PLUGIN_NAME" ]; then
        # For plugins
        zsh_add_file "plugins/$PLUGIN_NAME/$PLUGIN_NAME.plugin.zsh" || \
            zsh_add_file "plugins/$PLUGIN_NAME/$PLUGIN_NAME.zsh"
    else
        git clone "https://github.com/$1.git" "$ZDOTDIR/plugins/$PLUGIN_NAME"
    fi
}

function zsh_add_completion() {
    PLUGIN_NAME=$(echo $1 | cut -d "/" -f 2)
    if [ -d "$ZDOTDIR/plugins/$PLUGIN_NAME" ]; then
        # For completions
        completion_file_path=$(ls $ZDOTDIR/plugins/$PLUGIN_NAME/_*)
        fpath+="$(dirname "${completion_file_path}")"
        zsh_add_file "plugins/$PLUGIN_NAME/$PLUGIN_NAME.plugin.zsh"
    else
        git clone "https://github.com/$1.git" "$ZDOTDIR/plugins/$PLUGIN_NAME"
        fpath+=$(ls $ZDOTDIR/plugins/$PLUGIN_NAME/_*)
        [ -f $ZDOTDIR/.zccompdump ] && $ZDOTDIR/zccompdump
    fi
    completion_file="$(basename "${completion_file_path}")"
    if [ "$2" = true ] && compinit "${completion_file:1}"
}

function mkcd() {
    mkdir -p "$1" && cd "$1"
}

function fzf_preview() {
    if [[ -d $1 ]]; then
        tree --dirsfirst -a -C -L 1 "$1"
    elif [[ -f $1 ]]; then
        bat --style numbers,changes --color=always "$1" | head -500
    else
        echo "no preview"
    fi
}

function fuzzy_open() {
    if [ $1 ]; then
        dir=$(
            fd --hidden --exclude .git --print0 |
            fzf --read0 --print0 --exit-0 --query --preview="zsh -e $(functions fzf_preview); fzf_preview {}" $1
        )
    else
        dir=$(
            fd --hidden --exclude .git --print0 |
            fzf --read0 --print0 --exit-0 --preview="zsh -e $(functions fzf_preview); fzf_preview {}"
        )
    fi

    if [ -d $dir ]; then
        dir=$(echo $dir | sed 's/.$//')
        cd "$dir"
    else
        $EDITOR $dir
    fi
}

function fuzzy_tmux_kill() {
    if [ $1 ]; then
        tmux kill-session -t $1
        return
    fi
    STR=$(tmux list-sessions -F \#S 2>/dev/null | fzf --exit-0)
    [[ $STR ]] && tmux kill-session -t $STR
}

function fuzzy_tmux_session() {
    [[ -n "$TMUX" ]] && change="switch-client" || change="attach-session"
    session=$(
        tmux list-sessions -F \#S 2>/dev/null |
        fzf --select-1 --exit-0 --preview="tmux lsw -F '#{window_id} #{window_name}' -t {}"
    ) && tmux $change -t "$session" || echo "No sessions found"
}

function tmux_new_session() {
    [[ -n "$TMUX" ]] && change="switch-client" || change="attach-session"
    session=$(pwd | xargs basename | tr . _)
    if ! tmux has-session -t "$session" 2>/dev/null; then
        tmux new-session -ds "$session"
    fi
    tmux $change -t "$session"
}

function open_dev_project() {
    if [[ $1 ]]; then
        dir="$HOME"/dev/"$1"
    else
        dir=$(find $HOME/dev -mindepth 1 -maxdepth 1 -type d | fzf)
    fi
    if [[ -z $dir ]]; then
        echo "no project selected"
        return
    fi
    name=$(basename "$dir" | tr . _)
    tmux_running=$(pgrep tmux)
    if [[ -z $TMUX ]] && [[ -z $tmux_running ]]; then
        tmux new-session -s "$name" -c "$dir"
        return
    fi
    if ! tmux has-session -t="$name" 2> /dev/null; then
        tmux new-session -s "$name" -c "$dir" -d
    fi
    if [[ -z $TMUX ]]; then
        tmux attach-session -t "$name"
    else
        tmux switch-client -t "$name"
    fi
}

function new_dev_project() {
    read name\?"new project name: "
    dir="$HOME"/dev/"$name"
    git init "$dir"
    header=${(C)$(echo "$name" | tr "\-\_" " ")}
    echo "# $header" > "$dir"/README.md
    open_dev_project "$name"
}

function git_commit() {
    init=0
    while getopts "i" flag; do
        case $flag in
            i) init=1
        esac
    done
    if [[ $init > 0 ]]; then
        git commit -m "init commit"
        return
    fi

    $EDITOR tmp
    str=$(<tmp)
    rm tmp
    arr=(${(f)str})

    msg=$arr[1]
    if [[ -z $msg ]]; then
        echo "error: commit message empty"
        return
    fi
    echo "commit message: $msg"

    desc=$arr[2]
    if [[ -n $desc ]]; then
        echo "commit description: $desc"
    fi

    types="\
build:    changes that affect the build system or external dependencies\n\
chore:    changes that do not relate to a fix or feature and don't modify src or test files (for example updating dependencies)\n\
ci:       continuous integration related\n\
docs:     updates to documentation such as a the README or other markdown files\n\
feat:     a new feature is introduced with the changes\n\
fix:      a bug fix has occurred\n\
perf:     performance improvements\n\
refactor: refactored code that neither fixes a bug nor adds a feature\n\
revert:   reverts a previous commit\
style:    changes that do not affect the meaning of the code, likely related to code formatting such as white-space, missing semi-colons, and so on.\n\
test:     including new or correcting previous tests\
"
    type=$(
        echo $types |
        fzf --delimiter ":" -n 1 --preview "echo {1}: {2}" --preview-window="wrap" --bind "enter:become(echo {1})"
    )
    if [ -z $type ]; then
        echo "error: no commit type selected"
        return
    fi
    echo "commit type: $type"

    read scope\?"commit scope: "
    if [ -z $scope ]; then
        msg="$type: $msg"
    else
        msg="$type($scope): $msg"
    fi

    if [[ -n $desc ]]; then
        git commit -m "$msg" -m "$desc"
    else
        git commit -m "$msg"
    fi
}

function fuzzy_git_checkout() {
    if [ $1 ]; then
        git branch --all |
        grep -v '^[*+]' |
        awk '{print $1}' |
        sed 's/remotes\///g' |
        fzf --print0 --exit-0 --preview='git log --graph --oneline --decorate --all --color=always' --query $1 |
        xargs -r0 git checkout
        return
    fi
    git branch --all |
    grep -v '^[*+]' |
    awk '{print $1}' |
    sed 's/remotes\///g' |
    fzf --print0 --exit-0 --preview='git log --graph --oneline --decorate --all --color=always' |
    xargs -r0 git checkout
}

function fuzzy_git_add() {
    if [ $# -gt 0 ]; then
        git add $*
    else
        git ls-files -m -o --exclude-standard |
        fzf -m --print0 --exit-0 \
            --preview='git diff -w --color=always {}' \
            --bind='ctrl-o:become($EDITOR {} < /dev/tty > /dev/tty)' |
        xargs -r0 git add
    fi
}

function fuzzy_git_diff() {
    if [ $# -gt 0 ]; then
        git diff $*
    else
        git ls-files -m -o --exclude-standard |
        fzf -m --print0 --exit-0 \
            --preview='git diff -w --color=always {}' \
            --bind='ctrl-o:become($EDITOR {} < /dev/tty > /dev/tty)' |
        xargs -r0 git diff -w --color=always
    fi
}

function fuzzy_reverse_search() {
    local selected num
    selected=($(
            fc -rl 1 |
            awk '{ cmd=$0; sub(/^[ \t]*[0-9]+\**[ \t]+/, "", cmd); if (!seen[cmd]++) print $0 }' |
            fzf --no-preview
    ))
    local res=$?
    if [ -n "$selected" ]; then
        num=$selected[1]
        if [ -n "$num" ]; then
            zle vi-fetch-history -n $num
        fi
    fi
    zle reset-prompt
    return $ret
}
